// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package generated

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"carsdb/internal/database/model"
)

func newModelResult(db *gorm.DB, opts ...gen.DOOption) modelResult {
	_modelResult := modelResult{}

	_modelResult.modelResultDo.UseDB(db, opts...)
	_modelResult.modelResultDo.UseModel(&model.ModelResult{})

	tableName := _modelResult.modelResultDo.TableName()
	_modelResult.ALL = field.NewAsterisk(tableName)
	_modelResult.ID = field.NewInt32(tableName, "id")
	_modelResult.CreatedAt = field.NewTime(tableName, "created_at")
	_modelResult.Registration = field.NewString(tableName, "registration")
	_modelResult.Images = field.NewString(tableName, "images")
	_modelResult.Gearbox = field.NewString(tableName, "gearbox")
	_modelResult.Mileage = field.NewInt64(tableName, "mileage")
	_modelResult.Price = field.NewInt64(tableName, "price")
	_modelResult.Fuel = field.NewString(tableName, "fuel")
	_modelResult.Description = field.NewString(tableName, "description")
	_modelResult.EngineSize = field.NewString(tableName, "engine_size")
	_modelResult.Spec = field.NewString(tableName, "spec")
	_modelResult.Owners = field.NewInt64(tableName, "owners")
	_modelResult.URL = field.NewString(tableName, "url")
	_modelResult.Seller = field.NewString(tableName, "seller")
	_modelResult.Year = field.NewInt64(tableName, "year")
	_modelResult.ModelID = field.NewInt32(tableName, "model_id")
	_modelResult.JobID = field.NewString(tableName, "job_id")
	_modelResult.SourceID = field.NewString(tableName, "source_id")
	_modelResult.Power = field.NewString(tableName, "power")
	_modelResult.JobSourceID = field.NewInt64(tableName, "job_source_id")
	_modelResult.Cat = field.NewString(tableName, "cat")
	_modelResult.Colour = field.NewString(tableName, "colour")
	_modelResult.Doors = field.NewInt64(tableName, "doors")
	_modelResult.DriveType = field.NewString(tableName, "driveType")
	_modelResult.BodyType = field.NewString(tableName, "bodyType")
	_modelResult.SaleType = field.NewString(tableName, "sale_type")

	_modelResult.fillFieldMap()

	return _modelResult
}

type modelResult struct {
	modelResultDo

	ALL          field.Asterisk
	ID           field.Int32
	CreatedAt    field.Time
	Registration field.String
	Images       field.String
	Gearbox      field.String
	Mileage      field.Int64
	Price        field.Int64
	Fuel         field.String
	Description  field.String
	EngineSize   field.String
	Spec         field.String
	Owners       field.Int64
	URL          field.String
	Seller       field.String
	Year         field.Int64
	ModelID      field.Int32
	JobID        field.String
	SourceID     field.String
	Power        field.String
	JobSourceID  field.Int64
	Cat          field.String
	Colour       field.String
	Doors        field.Int64
	DriveType    field.String
	BodyType     field.String
	SaleType     field.String

	fieldMap map[string]field.Expr
}

func (m modelResult) Table(newTableName string) *modelResult {
	m.modelResultDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m modelResult) As(alias string) *modelResult {
	m.modelResultDo.DO = *(m.modelResultDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *modelResult) updateTableName(table string) *modelResult {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewInt32(table, "id")
	m.CreatedAt = field.NewTime(table, "created_at")
	m.Registration = field.NewString(table, "registration")
	m.Images = field.NewString(table, "images")
	m.Gearbox = field.NewString(table, "gearbox")
	m.Mileage = field.NewInt64(table, "mileage")
	m.Price = field.NewInt64(table, "price")
	m.Fuel = field.NewString(table, "fuel")
	m.Description = field.NewString(table, "description")
	m.EngineSize = field.NewString(table, "engine_size")
	m.Spec = field.NewString(table, "spec")
	m.Owners = field.NewInt64(table, "owners")
	m.URL = field.NewString(table, "url")
	m.Seller = field.NewString(table, "seller")
	m.Year = field.NewInt64(table, "year")
	m.ModelID = field.NewInt32(table, "model_id")
	m.JobID = field.NewString(table, "job_id")
	m.SourceID = field.NewString(table, "source_id")
	m.Power = field.NewString(table, "power")
	m.JobSourceID = field.NewInt64(table, "job_source_id")
	m.Cat = field.NewString(table, "cat")
	m.Colour = field.NewString(table, "colour")
	m.Doors = field.NewInt64(table, "doors")
	m.DriveType = field.NewString(table, "driveType")
	m.BodyType = field.NewString(table, "bodyType")
	m.SaleType = field.NewString(table, "sale_type")

	m.fillFieldMap()

	return m
}

func (m *modelResult) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *modelResult) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 26)
	m.fieldMap["id"] = m.ID
	m.fieldMap["created_at"] = m.CreatedAt
	m.fieldMap["registration"] = m.Registration
	m.fieldMap["images"] = m.Images
	m.fieldMap["gearbox"] = m.Gearbox
	m.fieldMap["mileage"] = m.Mileage
	m.fieldMap["price"] = m.Price
	m.fieldMap["fuel"] = m.Fuel
	m.fieldMap["description"] = m.Description
	m.fieldMap["engine_size"] = m.EngineSize
	m.fieldMap["spec"] = m.Spec
	m.fieldMap["owners"] = m.Owners
	m.fieldMap["url"] = m.URL
	m.fieldMap["seller"] = m.Seller
	m.fieldMap["year"] = m.Year
	m.fieldMap["model_id"] = m.ModelID
	m.fieldMap["job_id"] = m.JobID
	m.fieldMap["source_id"] = m.SourceID
	m.fieldMap["power"] = m.Power
	m.fieldMap["job_source_id"] = m.JobSourceID
	m.fieldMap["cat"] = m.Cat
	m.fieldMap["colour"] = m.Colour
	m.fieldMap["doors"] = m.Doors
	m.fieldMap["driveType"] = m.DriveType
	m.fieldMap["bodyType"] = m.BodyType
	m.fieldMap["sale_type"] = m.SaleType
}

func (m modelResult) clone(db *gorm.DB) modelResult {
	m.modelResultDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m modelResult) replaceDB(db *gorm.DB) modelResult {
	m.modelResultDo.ReplaceDB(db)
	return m
}

type modelResultDo struct{ gen.DO }

type IModelResultDo interface {
	gen.SubQuery
	Debug() IModelResultDo
	WithContext(ctx context.Context) IModelResultDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IModelResultDo
	WriteDB() IModelResultDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IModelResultDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IModelResultDo
	Not(conds ...gen.Condition) IModelResultDo
	Or(conds ...gen.Condition) IModelResultDo
	Select(conds ...field.Expr) IModelResultDo
	Where(conds ...gen.Condition) IModelResultDo
	Order(conds ...field.Expr) IModelResultDo
	Distinct(cols ...field.Expr) IModelResultDo
	Omit(cols ...field.Expr) IModelResultDo
	Join(table schema.Tabler, on ...field.Expr) IModelResultDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IModelResultDo
	RightJoin(table schema.Tabler, on ...field.Expr) IModelResultDo
	Group(cols ...field.Expr) IModelResultDo
	Having(conds ...gen.Condition) IModelResultDo
	Limit(limit int) IModelResultDo
	Offset(offset int) IModelResultDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IModelResultDo
	Unscoped() IModelResultDo
	Create(values ...*model.ModelResult) error
	CreateInBatches(values []*model.ModelResult, batchSize int) error
	Save(values ...*model.ModelResult) error
	First() (*model.ModelResult, error)
	Take() (*model.ModelResult, error)
	Last() (*model.ModelResult, error)
	Find() ([]*model.ModelResult, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ModelResult, err error)
	FindInBatches(result *[]*model.ModelResult, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ModelResult) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IModelResultDo
	Assign(attrs ...field.AssignExpr) IModelResultDo
	Joins(fields ...field.RelationField) IModelResultDo
	Preload(fields ...field.RelationField) IModelResultDo
	FirstOrInit() (*model.ModelResult, error)
	FirstOrCreate() (*model.ModelResult, error)
	FindByPage(offset int, limit int) (result []*model.ModelResult, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IModelResultDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m modelResultDo) Debug() IModelResultDo {
	return m.withDO(m.DO.Debug())
}

func (m modelResultDo) WithContext(ctx context.Context) IModelResultDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m modelResultDo) ReadDB() IModelResultDo {
	return m.Clauses(dbresolver.Read)
}

func (m modelResultDo) WriteDB() IModelResultDo {
	return m.Clauses(dbresolver.Write)
}

func (m modelResultDo) Session(config *gorm.Session) IModelResultDo {
	return m.withDO(m.DO.Session(config))
}

func (m modelResultDo) Clauses(conds ...clause.Expression) IModelResultDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m modelResultDo) Returning(value interface{}, columns ...string) IModelResultDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m modelResultDo) Not(conds ...gen.Condition) IModelResultDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m modelResultDo) Or(conds ...gen.Condition) IModelResultDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m modelResultDo) Select(conds ...field.Expr) IModelResultDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m modelResultDo) Where(conds ...gen.Condition) IModelResultDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m modelResultDo) Order(conds ...field.Expr) IModelResultDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m modelResultDo) Distinct(cols ...field.Expr) IModelResultDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m modelResultDo) Omit(cols ...field.Expr) IModelResultDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m modelResultDo) Join(table schema.Tabler, on ...field.Expr) IModelResultDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m modelResultDo) LeftJoin(table schema.Tabler, on ...field.Expr) IModelResultDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m modelResultDo) RightJoin(table schema.Tabler, on ...field.Expr) IModelResultDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m modelResultDo) Group(cols ...field.Expr) IModelResultDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m modelResultDo) Having(conds ...gen.Condition) IModelResultDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m modelResultDo) Limit(limit int) IModelResultDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m modelResultDo) Offset(offset int) IModelResultDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m modelResultDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IModelResultDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m modelResultDo) Unscoped() IModelResultDo {
	return m.withDO(m.DO.Unscoped())
}

func (m modelResultDo) Create(values ...*model.ModelResult) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m modelResultDo) CreateInBatches(values []*model.ModelResult, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m modelResultDo) Save(values ...*model.ModelResult) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m modelResultDo) First() (*model.ModelResult, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelResult), nil
	}
}

func (m modelResultDo) Take() (*model.ModelResult, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelResult), nil
	}
}

func (m modelResultDo) Last() (*model.ModelResult, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelResult), nil
	}
}

func (m modelResultDo) Find() ([]*model.ModelResult, error) {
	result, err := m.DO.Find()
	return result.([]*model.ModelResult), err
}

func (m modelResultDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ModelResult, err error) {
	buf := make([]*model.ModelResult, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m modelResultDo) FindInBatches(result *[]*model.ModelResult, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m modelResultDo) Attrs(attrs ...field.AssignExpr) IModelResultDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m modelResultDo) Assign(attrs ...field.AssignExpr) IModelResultDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m modelResultDo) Joins(fields ...field.RelationField) IModelResultDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m modelResultDo) Preload(fields ...field.RelationField) IModelResultDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m modelResultDo) FirstOrInit() (*model.ModelResult, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelResult), nil
	}
}

func (m modelResultDo) FirstOrCreate() (*model.ModelResult, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ModelResult), nil
	}
}

func (m modelResultDo) FindByPage(offset int, limit int) (result []*model.ModelResult, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m modelResultDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m modelResultDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m modelResultDo) Delete(models ...*model.ModelResult) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *modelResultDo) withDO(do gen.Dao) *modelResultDo {
	m.DO = *do.(*gen.DO)
	return m
}
